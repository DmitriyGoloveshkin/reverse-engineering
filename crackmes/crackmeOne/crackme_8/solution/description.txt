Подробно разбирать задачу в этот раз не буду. Опишу ключевые моменты.

1.	Для перехода на корректные инструкции используется следующий механизм:
	call    call_to_rip_plus_1

	call_to_rip_plus_1 proc near 
    pop     rcx
    add     rcx, 1
    jmp     rcx

2.	Итоговые сообщения хранятся в зашифрованном виде. Их расшифрока происходит
	по результатам проверки валидности введенного ключа.

3.	Код проверки валидности изначально живет в виде данных (зашифрованных и
	перемешанных). Перед вызовом этих инструкций производится расшифровка (
	xor и перестановки), после чего правильные значения команд помещаются на
	стек.

4. 	Для возможности выполнения кода, расположенного на стеке, используется
	функция VirtualProtect с параметром flNewProtect = 0x40. После чего по этим
	адресам передаются управление. 

Подходящих ключей достаточно много. Точное количество не проверил. Написал
keygen, который выдает первые 100*100 ключей.

Рассматриваемая задача является улучшенным продолжением первой задачи автора.
С первой задачей можно познакомиться на сайте. Ссылка на вторую задачу указана в 
source.txt.