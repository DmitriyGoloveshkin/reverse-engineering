Пришло время описать еще одну задачу. На мой взгляд, задача достаточно сильно 
качественно отличается ото всех предыдущих, с которыми мне довелось иметь дело.

Забегая вперед, скажу: не знаю, могу ли я считать эту задачу решенной или же
нет. Если критерий решения - ключ, при вводе которого программа выдает сообщение
об успехе, то задачу я не решил. Если же решением считать хорошее понимание 
происходящих вещей, то я скорее справился успешно, хоть и не без огрехов.

В любом случае задача мне очень зашла, рекомендую к исcледованию. Потрогал много
нового и интересного, о чем читал в умных книжках!

Обо всем по порядку. 
При запуске программы сходу на экране появляется окно с заголовком "haha!" и 
сообщением "you do not have a license, you are a noob!:D". Вот так. Ни запроса
на ввод, ни "до свидания". Как-то корявенько. Делать нечего, открываю IDA и 
начинаю исследовать. Сходу ничего не понятно. Принятие. Разбираюсь. 
Первая мысль - пользовательский ввод нужно передавать при запуске программы;
пробую, ничего не изменилось. Второя мысль - должен быть файлик с паролем, 
который программа ищет и сверяет содержимое. Но ничего такого вроде и не видно.

Строки я посмотрел, ничего не увидел, поулыбался и задумался. Ладно, тут я не 
удивился, т.к. много раз подобное видел в недавних задачах.

Включаю отладчик, начинаю изучение. Первое что заставило задуматься - обращение 
к PEB-у через gs:60h. Далее происходило что-то странное из этой же серии. 
Стало интересно, что же здесь происходит. В двух словах: через PEB добывается 
доступ к InOrderModuleList. Далее цикл по всем элементам этого списка в поисках
нужных модулей/библиотек. Мне понравилось, что строки искались не в лоб, а через 
вычисление контрольных сумм имен, после чего сверялось значение КС с зараннее
вычисленным значением. В случае обнаружения нужной библиотеки ее адрес помещался
в переменные для дальнейшего использования. Этот прием использовался в коде 
использовался неоднократно. Адрес библиотеки нашли, здорово! Двигаемся дальше.
Библиотека искалась не для забавы, из нее нужно было достать функции! Тут еще 
стало интереснее. Зная адрес библиотеки, в память копируется PE заголовок. 
(Совсем не понятно, зачем его копировать в память повторно). Через PE заголовок 
получили доступ к таблице экспорта, далее через таблицы имен, адресов и индесков
определялся адрес нужно библиотечной функции. Имена функций также искались через 
вычисление контрольной суммы. Что было найдено:

Библиотека          функция
kernel32.dll        GetCurrentThread
ntdll.dll           NtSetInformationThread
kernel32.dll        isDebuggerPresent
ucrtbase.dll        ucrtbase_system
kernel32.dll        LoadLibrary
user32.dll          gapfnScSendMessage
kernel32.dll        GetSystemFirmwareTable

Все эти функции получали управление через регистровый вызов (call reg). Первым 
делом я почувствовал мощь NtSetInformationThread. Ответ убил) Отладчик признаков
жизни не подает. Иду читать документацию и статьи. Разобрался. Занопил вызов.
Ну, с isDebbugPresent я уже знаком, поэтому просто его занопил. (Через время до
меня дошло, что возвращаемое значение нужно занулить. Кто же знал, что оно
придумает где-то провериться). Анти-анти-отладочные мероприятия закончились. 
Более ничего не мешает разбираться в логике программы.

Следующее, что хочется отметить - GetSystemFirmwareTable. Эта функция ловко 
вызывалась с аргументом FirmwareTableProviderSignature = RSMB в виде dword-a.
SMBIOS таблица! Вот те на! Неожиданно. *про себя радуюсь, что знаю кое-что о 
них; не так страшно*. Первым вызовом определили размер RawSMBIOSData, вторым - 
получили данные. Начинается парсинг этих данных. Какая-то каша! До сих пор не 
понимаю, что хотел сказать автор. Супер странным методом начинается обработка 
данных. Поняв принцип и не найдя логики, патчу переход. 
Вот тут и начинается точка отсчета. По адресу, (который должен был быть найден)
считываются 16 байт из SMBIOS и разносятся по переменным. Начинается адовый 
XOR-ing через YMM регистры. (XMM позвал старшего брата. Который ничем, кроме 
размера, не отличается от своего младшего братишки). На этом этапе начинается 
добыча строки формата, состоящей из "%02x" и так в итоге около 36 раз. Примерно.
После чего считанные прежде 16 байт превратились в строку из 36 символов при 
использовании vsprintf-a. Не буду задерживаться на этом подробнее. Оказывается, 
это и есть искомая с самого начала лицензия!
Что же происходит с этой строкой? Происходит с ней всякое. Иногда странное, 
иногда непонятное. В общем строка копируется, проверяется, ... Строка есть 
строка! Оставим промежуточные дествия и перейдем к валидации. Легко сказать!
CRC32 пришел откуда не ждали! Алгоритм валидации предельно прост: несколько 
ксоров, парочка сдвигов, значение от предыдущей итерации и все. Но так 36 раз!
Задумался, загрустил, задумался еще несколько раз. В итоге я понял, что
забрутфорсить это точно не получится. Попробовал как-то упростить/преобразовать.
Без толку. Погуглил и понял, что это CRC32. Что с ним делать - не знаю. Тут я и 
остановился. Ловким движением пропатчил нить выполнения в противоположную ветку.

Получил свое сообщение об успехе, вызванное через найденный MessageBox. Все
сообщения опять же ксорились перед использованием. 

Воот. Как-то так. 
Много чего пропустил, забыл. Но в целом внутренний мир этой крекмишки таков. 
Еще зацепил и не дает покоя неоднократно встречающийся код:
	xor eax, eax
	cmp eax, 1
	jnz ...
Бессмыслица. На превый взгляд, действительно так. У меня есть две версии, для 
чего это здесь есть:
1. Запутать бедолагу исследователя.
2. Этот код изменяется и приобретает нормальную функциональность.

Не могу сказать, в чем сила этой конструкции, но склоняюсь к первому варианту.

В общем встретил такую задачку, чему очень рад! Потрогал PEB, PE-шные заголовки,
таблицу экспорта со всеми вытекающими. Узнал и поработал с новыми вещами, о 
которых имел только теоретические знания. Встретил старого друга - SMBIOS-a, 
чему был крайне удивлен. Неожиданное решение спрятать ключ в SMBIOS. 
Промелькнула мысль, что это может быть лицензионный ключ от Windows. В общем,
остались загадки, на которые не обязательно есть ответы. Душа автора - потемки.

В заключение повторюсь, что не понимаю: можно ли считать такую задачу решенной 
или нет. В любом случае она отправляется в репозиторий к своим точно решенным 
собратьям.